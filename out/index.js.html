<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var assert = require('assert'),
	config = (require('../config'))[process.env.profile || 'dev'],
	async = require('async'),
	SandBox = require('sandboxed-module'),
	ObjectID = require("mongodb").ObjectID,
	util = require('util'),
	_ = require('lodash'),
	constants = createConstants(),
	vm = require('vm'),
	fs = require('fs'),
	generator = require('mongoose-gen'),
	glob = require('glob'),
	path = require('path'),
	mongoose = require('mongoose');


mongoose.connect(config.data.url);

/**
 * Returns Array of Strings
 * @param  {String} folderPath
 * @param  {Function} callback
 * @return {String}
 */
var getDirectories = function(src, callback) {
	glob(src + '/**/*', callback);
};

/**
 * Returns a function that checks if a property is defined
 * @param  {String} propertyName
 * @return {Function}
 */
var isNotDefined = function(prop) {
	return function(item) {
		return typeof item == "object" &amp;&amp; typeof item[prop] == 'undefined';
	};
};

/**
 * Returns a function that checks the type of the supplied argument
 * @param  {String} value
 * @return {Function}
 */
var typeOf = function(value) {
	return function(item) {
		return typeof item == value;
	};
};

/**
 * Returns a function that returns the first child of an array result.
 * @param  {Function} fn
 * @return {Any}
 */
var getOne = function(fn) {
	return function(er, result) {
		if (result &amp;&amp; result.length) {
			result = result[0];
		}
		return fn(er, result);
	};
};

var notAFunction = function(x) {
	return typeof x !== "function";
};

/**
 * Capitalizes Text
 * @param  {String} txt
 * @return {String}
 */
function capitalizeText(txt) {
	return txt ? txt.charAt(0).toUpperCase() + txt.slice(1) : txt;
}

var systemEntities = {
	step: '_0Step',
	processor: '_0Processor',
	commandProcessor: '_0CommandProcessor',
	process: '_0Process',
	asyncValidator: '_0AsyncValidator',
	element: '_0Element'
};

function createConstants() {
	function Constant() {
		var array = Array.prototype.slice.call(arguments);
		for (var i = 0; i &lt; array.length; i++) {
			if (typeof array[i] == 'string') {
				this[array[i]] = array[i];
				continue;
			}
			if (array[i].length == 1) {
				this[array[i][0]] = array[i][0];
				continue;
			}
			this[array[i][0]] = array[i][1];
		}
	}
	Constant.prototype.in = function(val) {
		for (var i in this) {
			if (this.hasOwnProperty(i) &amp;&amp; this[i] == val)
				return true;
		}
		return false;
	};

	return {
		PROCESSSTATUS: new Constant('COMPLETED', 'RUNNING'),
		PROCESSORTYPE: new Constant('SERVER', 'CLIENT'),
		STEPTYPE: new Constant('OFFLINE', 'CLIENT')
	};
}

/*********
 *   DynamoStep Class:- this represents a dynamo step. Steps could be either require userinput or not.
 *
 ***********/
function DynamoStep(opts) {
	var self = this;
	if (!opts.processors || !opts.processors.length)
		throw new Error('opts.processors must have atleast one processor');


	if (!opts.stepType || !constants.STEPTYPE.in(opts.stepType))
		throw new Error('opts.type is null or undefined or not a valid type');

	if (!opts.save)
		throw new Error('Step needs save service for persistence');

	this._id = opts._id;
	this.stepType = opts.stepType;
	this._save = opts.save;
	var postprocessors = opts.postprocessors || [];
	_state = getState.call(this, opts);


	Object.defineProperties(this, {
		'processors': {
			enumerable: false,
			get: function() {
				return opts.processors;
			}
		},
		'state': {
			enumerable: false,
			get: function() {
				return _state;
			}
		},
		'postprocessors': {
			enumerable: false,
			get: function() {
				return postprocessors;
			}
		},
		'form': {
			enumerable: false,
			get: function() {
				return opts.form;
			}
		}
	});

	function Offline(parent, opts) {
		this.run = function(context, fn) {
			//start offline process...
			//tell the caller that process has began
			fn(null, {
				message: 'process has started'
			});
		};
		this.save = function(fn) {
			fn({});
		};
		this.describe = function(fn) {
			fn({});
		};
	}

	function getState(opts) {
		switch (opts.stepType) {
			case constants.STEPTYPE.OFFLINE:
				return new Offline(this, opts);
			default:
				return new Client(this, opts);
		}
	}

	function Client(parent, opts) {
		if (!opts.form)
			throw new Error('Client Step must have a form');

		if (!opts.entityRepo)
			throw new Error('opts.entityRepo is required for this type of processor');

		//
		assert.equal(typeof opts.form.describe == 'function', true);

		this.form = opts.form;
		this.entityRepo = opts.entityRepo;

		function prepareContext(opts) {
			var _context = opts.args ? _.cloneDeep(opts.args) : {};
			_context.postprocessors = _.cloneDeep(opts.postprocessors);
			_context.processors = _.cloneDeep(opts.processors);
			_context.postprocessorsTimeout = config.postprocessors.ttl;
			_context.processorsTimeout = config.processors.ttl;
			return _context;
		}
		this.save = function(fn) {
			this.form.save(function(er, form) {
				if (er) return fn(er);
				fn(null, {
					form: form
				});
			});
		};

		//this calls all the processors of the step.
		this.run = function(context, fn) {
			var self = this;
			var serverProcessors = _.filter(parent.processors, ['processorType', constants.PROCESSORTYPE.SERVER]),
				_context = prepareContext({
					processors: serverProcessors,
					args: context,
					postprocessors: (parent.postprocessors &amp;&amp; _.find(parent.postprocessors, q) ? _.filter(parent.postprocessors, q) : null)
				}),
				handle = SandBox.require('./processor-sandbox', {
					locals: {
						context: _context,
						constants: constants,
						entityRepo: self.entityRepo,
						async: async,
					}
				});
			handle.getResult(function(er, result) {
				if (er) return fn(er);
				return parent.status = constants.STEPSTATUS.COMPLETED, fn(null, result);
			});
		};

		this.describe = function(fn) {
			this.form.describe(fn);
		};
	}

}

DynamoStep.prototype.save = function(fn) {

	var self = this;
	var unsavedProcessors = _.filter(this.processors, isNotDefined('_id'));
	var unsavedPostProcessors = _.filter(this.postprocessors, isNotDefined('_id'));
	var tasks = [],
		saveFn = function(list) {
			return function(pending) {
				function s(callback) {
					pending.save(function(er, result) {
						callback(er, result);
					});
				}
				list.push(s);
			};
		},
		postTasks = [],
		elements = [];
	unsavedProcessors.forEach(saveFn(tasks));
	unsavedPostProcessors.forEach(saveFn(postTasks));
	async.waterfall([
		async.parallel.bind(async, tasks),
		function(ids, callback) {

			async.parallel(postTasks, function(er, items) {

				callback(er, {
					processors: ids,
					postprocessors: items
				});
			});
		},
		function(ids, callback) {
			//ids will contain the newly saved ids
			//

			var processorIds = _.filter(self.processors, typeOf('string')).concat(_.map(ids.processors, '_id'));
			var postprocessorIds = _.filter(self.postprocessors, typeOf('string')).concat(_.map(ids.postprocessors, '_id'));
			self.state.save(function(er, state) {



				self._save(_.assign({
					_id: self._id,
					processors: processorIds,
					postprocessors: postprocessorIds,
					stepType: self.stepType
				}, state || {}), callback);
			});

		}
	], fn);

};

DynamoStep.prototype.validate = function() {
	if (!this._id)
		throw new Error('opts._id is null or undefined');
};

DynamoStep.prototype.describe = function(fn) {
	this.validate();
	var self = this,
		step = _.pickBy(self, notAFunction),
		_processors = [],
		_postprocessors = [],
		sent = false,
		collected = 0,
		total = self.processors.length + (self.postprocessors ? self.postprocessors.length : 0),
		collect = function(dest) {
			return function(er, p) {
				if (er) {
					return sent = true, fn(er);
				}
				if (!sent) {
					collected++;
					dest.push(p);
					if (collected == total &amp;&amp; !sent) {
						return step.processors = _processors,
							step.postprocessors = _postprocessors,
							sent = true, fn(null, step);
					}
				}

			};
		},
		i = 0;
	self.state.describe(function(er, res) {
		if (er) return fn(er);

		_.assign(step, res);

		for (i = 0; i &lt; self.processors.length; i++) {
			self.processors[i].describe(collect(_processors));
		}

		if (self.postprocessors &amp;&amp; self.postprocessors.length)
			for (i = 0; i &lt; self.postprocessors.length; i++)
				self.postprocessors[i].describe(collect(_postprocessors));
	});

};

DynamoStep.prototype.run = function(context, fn) {
	this.validate();
	this.state.run(context, fn);
};



/***********
 *   DynamoProcess Class:- this represents a dynamo process.
 *
 ***********/
function DynamoProcess(opts) {
	var self = this;
	if (!opts)
		throw new Error('Process arg missing');

	if (!opts.steps || !opts.steps.length)
		throw new Error('Process must contain atleast one step');

	if (!opts.title)
		throw new Error('Process must have a title');

	if (!opts.store &amp;&amp; opts.steps.length > 1)
		throw new Error('Process with more than one step requires a store');

	if (!opts.save)
		throw new Error('Process needs save service for persistence');

	var currentStep = null;
	this._id = opts._id;
	this.description = opts.description;
	this.title = opts.title;
	this._save = opts.save;
	Object.defineProperties(self, {
		'steps': {
			enumerable: false,
			get: function() {
				return opts.steps;
			}
		},
		'currentStep': {
			enumerable: false,
			get: function() {
				return currentStep;
			}
		},
		'store': {
			enumerable: false,
			get: function() {
				return store;
			}
		}
	});
}

DynamoProcess.prototype.validate = function(fn) {
	if (!this._id)
		throw new Error('Process must have an id');
};

DynamoProcess.prototype.processCurrentStep = function(context, fn) {
	var self = this;
	this.validate();

	function processStep(args) {
		var step = self.steps[self.currentStepIndex || 0];
		assert.equal(step instanceof DynamoStep, true);
		step.run(context, function(er, message) {
			if (er) return fn(er);

			self.currentStepIndex = self.steps.indexOf(step) + 1;
			fn(null, _.assign(self.steps.length &lt;= self.currentStepIndex ?
				(self.status = constants.PROCESSSTATUS.RUNNING, {
					status: self.status,
					message: message
				}) : (self.status = constants.PROCESSSTATUS.COMPLETED, {
					status: self.status,
					message: message
				}), args || {}));
		});
	}
	if (this.steps.length > 1) {
		this.store.get((context.instanceId || ''), function(er, currentStep) {
			if (er) return fn(er);

			if (currentStep) {
				self.currentStepIndex = currentStep.value;
				processStep.call({
					instanceId: context.instanceId
				});
			} else {
				self.store.keep(currentStepIndex, function(er, data) {
					if (er) return fn(er);
					return processStep({
						instanceId: data._id
					});
				});
			}

		});



		return;
	}
	processStep();
};

DynamoProcess.prototype.save = function(fn) {
	var self = this;
	var unsaved = _.filter(this.steps, isNotDefined('_id'));
	var tasks = [];
	unsaved.forEach(function(pending) {
		function s(callback) {
			pending.save(function(er, result) {
				callback(er, result);
			});
		}
		tasks.push(s);
	});
	async.waterfall([
		async.parallel.bind(async, tasks),
		function(ids, callback) {
			//ids will contain the newly saved ids
			var mergedIds = _.filter(self.steps, function(x) {
				return (typeof x == 'object' &amp;&amp; x._id) || typeof x == 'string';
			}).concat(_.map(ids, '_id'));

			self._save({
				title: self.title,
				description: self.description,
				steps: mergedIds
			}, callback);
		}
	], fn);
};

DynamoProcess.prototype.describe = function(fn) {
	this.validate();
	var self = this,
		proc = _.pickBy(self,notAFunction),
		_allSteps = [];

	function collect(er, s) {
		if (er) return fn(er);
		_allSteps.push(s);

		if (self.steps.length == _allSteps.length) {
			proc.steps = _allSteps;
			return fn(null, proc);
		}
	}
	self.steps.forEach(function(s) {
		s.describe(collect);
	});
	proc.steps = _allSteps;
	return proc;
};


/***********
 *   DynamoEngine Class:- this represents a dynamo engine. Engine represents the boundary between the problem domain and the outside world.
 *
 ***********/
function DynamoEngine(opts) {
	var self = this;
	if (!opts)
		throw new Error('opts must be valid');


	if (!opts.entitiesRepository)
		throw new Error('opts.entitiesRepository must be valid');

	this.entitiesRepository = opts.entitiesRepository;


}

DynamoEngine.prototype.init = function(fn) {
	//create all system required configs if they dont exist.
	this.entitiesRepository.init(fn);

};

DynamoEngine.prototype.createEntityConfiguration = function(name, config, fn) {
	this.entitiesRepository.createConfig(name, config, fn);
};

DynamoEngine.prototype.updateEntityConfiguration = function(name, config, fn) {
	this.entitiesRepository.updateConfig(name, config, fn);
};

DynamoEngine.prototype.updateEntityInstance = function(name, data, fn) {
	this.entitiesRepository.updateEntity(name, data, fn);
};

DynamoEngine.prototype.createEntityInstance = function(name, data, fn) {
	this.entitiesRepository.createEntity(name, data, fn);
};
DynamoEngine.prototype.query = function(name, filter, options, fn) {
	this.entitiesRepository.query(name, filter, options, fn);
};

//---------------------------------------------------------------------------

Object.keys(systemEntities).forEach(function(key) {
	var cap = capitalizeText(key);
	var entName = systemEntities[key];
	DynamoEngine.prototype['query' + cap] = function(filter, options, fn) {
		if (Array.prototype.slice.call(arguments).length == 2) {
			fn = options;
			options = null;
		}
		this.entitiesRepository.queryEntity(entName, filter, options, fn);
	};
	DynamoEngine.prototype['save' + cap] = function(data, fn) {

		if (this.entitiesRepository.transformers[entName]) {

			//data.save = this.entitiesRepository.getSaveService(entName);
			var model = this.entitiesRepository.transformers[entName](data, function(er, model) {
				if (er) return fn(er);



				//
				model.save(fn);
			});
			return;
		}

		if (!data._id)
			this.entitiesRepository.createEntity(systemEntities[key], data, fn);
		else
			this.entitiesRepository.updateEntity(systemEntities[key], data, fn);
	};
});

//-------------------------------------------------------------------------

function DynamoElement(opts) {

	if (!opts)
		throw new Error('opts cannot be null');

	if (!opts.name)
		throw new Error('element name must be valid');

	if (!opts.elementType)
		throw new Error('element type must be valid');

	if (!opts.save)
		throw new Error('element must have persistence service');

	this._id = opts._id;
	this._save = opts.save;
	this.name = opts.name;
	this.elementType = opts.elementType;
	this.label = opts.label;
	this.description = opts.description;
	this.args = opts.args;
	this.asyncValidators = opts.asyncValidators || [];
	this.validators = opts.validators || [];
}
DynamoElement.prototype.describe = function(fn) {
	fn(null, {
		name: this.name,
		label: this.label,
		elementType: this.elementType,
		args: this.args,
		description: this.description,
		validators: this.validators,
		asyncValidators: _.map(this.asyncValidators, '_id')
	});
};

DynamoElement.prototype.save = function(fn) {
	this._save({
		_id: this._id,
		name: this.name,
		label: this.label,
		elementType: this.elementType,
		args: this.args,
		description: this.description,
		validators: this.validators,
		asyncValidators: _.map(this.asyncValidators, '_id')
	}, fn);
};



/******************************************
 *   DynamoForm Class:-
 *
 *****************************************/
function DynamoForm(opts) {
	if (!opts || !opts.elements || !opts.elements.length)
		throw new Error('Form does not contain any elements');


	this.elements = opts.elements;
}

DynamoForm.prototype.describe = function(fn) {
	async.parallel(_.map(this.elements, function(e) {
		return e.describe.bind(e);
	}), function(er, result) {
		if (er) return fn(er);
		fn(null, {
			elements: result
		});
	});
};

DynamoForm.prototype.save = function(fn) {
	async.parallel(_.map(this.elements, function(x) {
		return x.save.bind(x);
	}), function(er, elements) {
		if (er) return fn(er);
		fn(null, {
			elements: _.map(elements, '_id')
		});
	});
};

/*********
 *   DynamoProcessor Class:- this represents a dynamo engine. Engine represents the boundary between the problem domain and the outside world.
 *
 ***********/

function DynamoProcessor(opts) {



	if (!opts.code)
		throw new Error('Processor must include code to run');

	if (!opts.title)
		throw new Error('Processor must have a title');

	if (!opts.save)
		throw new Error('Processor needs save service for persistence');


	var self = this;
	this._id = opts._id;
	this.code = opts.code;
	this.title = opts.title;
	this._save = opts.save;
	this.process = function(result, callback) {
		self.validate();
		if (typeof result == 'function') {
			callback = result;
			result = null;
		}
		/* jshint ignore:start */
		if (this.SANDBOX_CONTEXT)
		//added extra check to ensure this code never runs in engine context.
			eval(self.code);
		/* jshint ignore:end */
	};
}

DynamoProcessor.prototype.validate = function() {
	if (!this._id)
		throw new Error('Processor requires a valid _id');
};

DynamoProcessor.prototype.describe = function(fn) {
	fn(null, {
		title: this.title,
		_id: this._id
	});
};

DynamoProcessor.prototype.save = function(fn) {
	//
	this._save({
		_id: this._id,
		code: this.code,
		title: this.title
	}, fn);
};

function DynamoAsyncValidator(opts) {
	var self = this;
	DynamoProcessor.call(this, opts);
	var _process = this.process;
	//convert result to boolean value.
	this.process = function(result, fn) {
		_process.call(this, result, function(er, result) {
			fn(er, {
				valid: !!result
			});
		});
	};

}


function EntityRepo(opts) {
	var self = this;
	opts = opts || {};
	this.models = {};
	this.schemas = {};
	this.validators = {};
	this.transformers = {};
	this.refs = {};
	this._changeDetection = {};
	this.entityExt = opts.ext || '.json';
	this.entityFolder = opts.folder || './src/entities/';
	this.delimiter = opts.delimiter || /('|")\$\{(\w+)\}+('|")/i;
	this._systemEntities = _.map(systemEntities, function(x) {
		return x;
	});
	this.store = opts.store || (function() {
		var collection = mongoose.connection.db.collection('_temp_store_');

		function createIndex(fn) {
			collection.createIndex({
				createdOn: 1
			}, {
				expireAfterSeconds: opts.storeTTL || 60
			}, fn);
		}
		return {
			get: function(id, fn) {
				collection.findOne({
					_id: id
				}, fn);
			},
			keep: function(info, fn) {
				createIndex(function() {
					collection.insertOne({
						value: info,
						createdOn: new Date()
					}, fn);
				});
			}
		};

	}());
	this.processorEntityRepo = {
		get: self.queryEntity,
		update: self.updateEntity,
		create: self.createEntity
	};

	this.transformers[systemEntities.process] = function(item, fn) {
		if (!(item instanceof DynamoProcess)) {
			var tasks = [];
			if (typeof item == "string" || item instanceof ObjectID) {
				tasks.push(self.queryEntity.bind(self, systemEntities.process, {
					_id: item
				}, {
					full: true,
					one: true
				}));
			} else {
				tasks.push(function(callback) {
					if (!item.save)
						item.save = self.getSaveService(systemEntities.process);
					if (item.steps.length > 1) {
						item.store = self.store;
					}
					var itasks = [];
					item.steps.forEach(function(step) {
						itasks.push(self.transformers[systemEntities.step].bind(self, step));
					});
					async.parallel(itasks, function(er, steps) {
						if (er) return callback(er);

						item.steps = steps;
						callback(null, new DynamoProcess(item));
					});
				});
			}
			return async.waterfall(tasks, fn);
		}
		return fn(null, item);
	};
	this.transformers[systemEntities.step] = function(item, fn) {
		if (!(item instanceof DynamoStep)) {
			var tasks = [],
				processorTasks = [],
				postprocessorTasks = [];
			if (typeof item == "string" || item instanceof ObjectID) {
				self.queryEntity(systemEntities.step, {
					_id: item
				}, {
					full: true,
					one: true
				}, fn);
			} else {

				if (!item.save)
					item.save = self.getSaveService(systemEntities.step);

				if (item.stepType == constants.STEPTYPE.CLIENT) {
					item.entityRepo = self.processorEntityRepo;
					tasks.push(function(callback) {
						self.transformers.form(item.form, function(er, form) {
							if (er) callback(er);
							item.form = form;
							return callback();
						});
					});
				}
				if (item.postprocessors) {
					item.postprocessors.forEach(function(proc) {
						postprocessorTasks.push(self.transformers[systemEntities.processor].bind(self, proc));
					});
					tasks.push(function(callback) {
						async.parallel(postprocessorTasks, function(er, postprocessors) {
							if (er) return callback(er);
							item.postprocessors = postprocessors;
							callback();
						});
					});
				}
				item.processors.forEach(function(proc) {
					processorTasks.push(self.transformers[systemEntities.processor].bind(self, proc));
				});
				tasks.push(function(callback) {
					async.parallel(processorTasks, function(er, processors) {
						if (er) return callback(er);
						item.processors = processors;
						callback();
					});
				});

				async.parallel(tasks, function(er) {
					if (er) return fn(er);


					return fn(null, new DynamoStep(item));
				});
			}
			return;
		}
		return fn(null, item);
	};
	this.transformers[systemEntities.asyncValidator] = function(item, fn) {
		if (!(item instanceof DynamoAsyncValidator)) {

			if (typeof item == "string" || item instanceof ObjectID) {
				return self.queryEntity(systemEntities.asyncValidator, {
					_id: item
				}, {
					full: true,
					one: true
				}, fn);

			}

			if (!item.save)
				item.save = self.getSaveService(systemEntities.asyncValidator);

			return fn(null, new DynamoAsyncValidator(item));
		}
		return fn(null, item);
	};
	this.transformers[systemEntities.processor] = function(item, fn) {

		if (!(item instanceof DynamoProcessor)) {

			if (typeof item == "string" || item instanceof ObjectID) {
				//
				return self.queryEntity(systemEntities.processor, {
					_id: item
				}, {
					full: true,
					one: true
				}, fn);
			}

			if (!item.save)
				item.save = self.getSaveService(systemEntities.processor);

			return fn(null, new DynamoProcessor(item));
		}
		return fn(null, item);
	};
	this.transformers[systemEntities.element] = function(item, fn) {
		if (!(item instanceof DynamoElement)) {

			if (typeof item == "string" || item instanceof ObjectID) {
				return self.queryEntity(systemEntities.element, {
					_id: item
				}, {
					full: true,
					one: true
				}, fn);
			}


			if (!item.save)
				item.save = self.getSaveService(systemEntities.element);

			async.parallel(_.map(item.asyncValidators, function(x) {
				return self.transformers[systemEntities.asyncValidator].bind(self, x);
			}), function(er, asyncValidators) {
				if (er) return fn(er);
				item.asyncValidators = asyncValidators;
				return fn(null, new DynamoElement(item));
			});
			return;
		}
		return fn(null, item);
	};
	this.transformers.form = function(item, fn) {
		if (!(item instanceof DynamoForm)) {
			async.parallel(_.map(item.elements, function(element) {
				return self.transformers[systemEntities.element].bind(self.transformers, element);
			}), function(er, elements) {
				if (er) return fn(er);
				item.elements = elements;
				return fn(null, new DynamoForm(item));
			});
			return;
		}
		return fn(null, form);
	};

}

EntityRepo.prototype.init = function(callback) {
	var self = this;

	async.parallel([
		fs.writeFile.bind(this, self.getPath(systemEntities.process), '{"title":{"type":"String","required":true},"description":{"type":"String","required":true},"steps":[{"type":"ObjectId","ref":"' + systemEntities.step + '"}]}'),
		fs.writeFile.bind(this, self.getPath(systemEntities.step), '{"processors":[{"type":"ObjectId","ref":"' + systemEntities.processor + '"}],"postprocessors":[{"type":"ObjectId","ref":"' + systemEntities.processor + '"}],"stepType":{"type":"String","required":true},"form":{"elements":[{"type":"ObjectId","ref":"' + systemEntities.element + '"}]}}'),
		fs.writeFile.bind(this, self.getPath(systemEntities.processor), '{"code":{"type":"String","required":true},"title":{"type":"String", "required":true}}'),
		fs.writeFile.bind(this, self.getPath(systemEntities.commandProcessor), '{"code":{"type":"String","required":true},"title":{"type":"String", "required":true}}'),
		fs.writeFile.bind(this, self.getPath(systemEntities.asyncValidator), '{"code":{"type":"String","required":true},"title":{"type":"String", "required":true}}'),
		fs.writeFile.bind(this, self.getPath(systemEntities.element), '{"name":{"type":"String","required":true},"label":{"type":"String","required":true},"description":{"type":"String"},"elementType":{"type":"String","enum":["INPUT","LARGEINPUT","COMMAND","SECTION","TABS","SELECT","LIST","IMAGE"]},"asyncValidators":[{"type":"ObjectId","ref":"' + systemEntities.asyncValidator + '"}],"validators":[{"validatorType":{"type":"String","enum":["REGULAR","SCRIPT"],"required":true},"args":{"type":"Mixed"}}],"args":{"type":"Mixed"}}')
	], function(er) {
		if (er) return callback(er);
		self.createSchemas(callback);
	});
};

//service injected into domain objects for persistence.
EntityRepo.prototype.getSaveService = function(entName) {
	var self = this;
	return function(info, fn) {

		function transformResult(er, result) {

			if (er) return fn(er);
			self.queryEntity(entName, {
				_id: result._id
			}, function(e, x) {

				fn(e, x[0]);
			});
		}
		if (!info._id)
			self.createEntity(entName, info, transformResult);
		else
			self.updateEntity(entName, info, transformResult);
	};
};
//used to create schema document.
EntityRepo.prototype.createConfig = function(name, config, fn) {
	if (this._systemEntities.indexOf(this.name) !== -1)
		throw new Error('Cannot Create Entity with that name.');
	var self = this;

	fs.writeFile(this.getPath(name), JSON.stringify(config), 'utf8', function(er) {
		if (er) return fn(er);
		self.createSchemas(fn);
	});
};

EntityRepo.prototype.getPath = function(name) {
	return this.entityFolder + name + this.entityExt;
};
//returns a schema document.
EntityRepo.prototype.getConfig = function(name, fn) {
	fs.readFile(this.getPath(name), {
		encoding: 'utf8'
	}, function(er, data) {
		try {
			data = JSON.parse(data);
		} catch (e) {
			return fn(new Error('Failed to parse config file'));
		}
		fn(er, data);
	});
};

EntityRepo.prototype.getAllConfiguration = function(fn) {
	var self = this;
	getDirectories(this.entityFolder, function(er, ents) {
		var tasks = [];
		ents.forEach(function(file) {
			if (file.indexOf(self.del) === -1)
				task.push(self.getConfig.bind(self, name));
		});
		async.parallel(tasks, fn);
	});
};

EntityRepo.prototype.updateConfig = function(name, config, fn) {
	if (this._systemEntities.indexOf(this.name) !== -1)
		throw new Error('Cannot Create Entity with that name.');
	var self = this;
	fs.truncate(this.getPath(name), function() {
		self.createConfig(name, config, fn);
	});
};

EntityRepo.prototype.queryEntity = function(name, filter, options, fn) {
	var self = this,
		circularDepth = options &amp;&amp; options.circularDepth ? options.circularDepth : 1,
		referenceCount = {},
		keys;
	if (Array.prototype.slice.call(arguments).length == 3) {
		fn = options;
		options = null;
	}

	function populate(arr, result, parent) {
		arr.forEach(function(item) {

			//
			if (parent &amp;&amp; new RegExp(item.path + '$').test(parent)) {
				referenceCount[item.model] = referenceCount[item.model] ? referenceCount[item.model] + 1 : 1;
			}

			result.push((parent ? parent + '.' : '') + item.path);
			if (self.refs[item.model] &amp;&amp; (referenceCount[item.model] || 0) &lt; circularDepth) {
				populate(self.refs[item.model], result, result[result.length - 1]);
			}
		});
		return result;
	}

	function transformResult(er, result) {
		if (er) return fn(er);
		if (self.transformers[name]) {
			async.parallel(_.map(result, function(x) {
				return self.transformers[name].bind(self.transformers, x);
			}), function(er, transformed) {
				if (er) return fn(er);
				if (options &amp;&amp; options.one &amp;&amp; transformed &amp;&amp; transformed.length)
					transformed = transformed[0];

				fn(null, transformed);
			});
			return;
		}

		fn(null, result);
	}

	if ((options &amp;&amp; !options.full) || !this.refs[name] || this.refs[name].length === 0) {
		this.models[name].find(filter).lean().exec(transformResult);
		return;
	}

	var query = this.models[name].find(filter);
	var populateString = populate(self.refs[name], []);

	populateString.forEach(function(string) {
		query.populate(string);
		// if (string.indexOf('.') == -1)
		// 	query.populate(string);
		// else {
		// 	var p = {},
		// 		splitString = string.split('.'),
		// 		curr = '',
		// 		sv = [];

		// 	splitString.forEach(function(x) {
		// 		if (populateString.indexOf(x) == -1) {
		// 			curr += x + '.';
		// 		} else {
		// 			curr += '|' + x;
		// 		}
		// 	});
		// 	//curr = curr.substring(0, curr.length - 1);
		// 	
		// 	_.reduce(curr.split('|'), function(m, n) {
		// 		if (!m.path) {
		// 			m.path = n;
		// 			return m;
		// 		}
		// 		m.populate = {
		// 			path: n
		// 		};
		// 		return m.populate;

		// 	}, p);


		// 	
		// 	query.populate(p);
		// }

	});


	if (options) {
		if (options.sort) {
			query = query.sort(options.sort);
		}
		if (options.limit) {
			query.limit(options.limit);
		}
	}

	query.lean().exec(transformResult);
};

EntityRepo.prototype.updateEntity = function(name, data, fn) {
	var self = this;
	if (this._changeDetection[name]) {

		this.models[name].findOne({
			_id: data._id
		}, function(er, e) {
			if (er) return fn(er);
			var merged = _.assign(e, data);
			self._changeDetection[name].forEach(function(field) {
				merged.set(field, data[field]);
			});
			merged.save(fn);
		});
	} else {
		this.models[name].update({
			_id: data._id
		}, data, fn);
	}

};

EntityRepo.prototype.createEntity = function(name, data, fn) {
	var item = new(this.models[name])(data);
	item.save(fn);
};


EntityRepo.prototype.createSchemas = function(fn) {
	var self = this;

	function createRunContext(code) {
		return function(value) {
			var sandbox = {
				value: value
			};
			var script = new vm.Script(code);
			var context = new vm.createContext(sandbox);
			script.runInNewContext(context);
			return !!sandbox.result;
		};
	}

	function assignModel(callback) {
		var that = this;
		try {

			var existing = self.models[this.prop] || mongoose.model(this.prop);
			var newSchema = JSON.parse(this.item);
			var diff = _.omitBy(newSchema, function(v, k) {
				return _.isEqual(self.schemas[that.prop][k], v);
			});
			var change = Object.keys(diff);
			if (diff &amp;&amp; change.length) {
				existing.schema.add(generator.convert(diff));
				self.models[this.prop] = existing;
				self.schemas[this.prop] = newSchema;
				self._changeDetection[this.prop] = change;
				self.refs[that.prop] = getRefs(newSchema);

			}
		} catch (e) {
			if (e.name == 'MissingSchemaError') {
				self.schemas[that.prop] = JSON.parse(that.item);
				self.refs[that.prop] = getRefs(self.schemas[that.prop]);
				var schema = new mongoose.Schema(generator.convert(self.schemas[that.prop]));
				self.models[that.prop] = mongoose.model(that.prop, schema);

			} else
				return callback(e);
		}

		callback();
	}

	function getRefs(file, key) {
		var props = Object.keys(file),
			refs = [];
		if (!key) key = '';
		props.forEach(function(prop) {
			if (prop == 'ref') {
				refs.push({
					model: file.ref,
					path: key.substring(0, key.length - 1)
				});
				return;
			}

			if (typeof file[prop] == 'object') {
				var obj = file[prop];
				if (obj instanceof Array) {
					if (typeof obj[0] == 'object')
						obj = obj[0];
					else
						return;
				}
				refs = refs.concat(getRefs(obj, key + prop + '.'));
				return;
			}
		});

		return refs;
	}

	function registerValidator(result, callback) {
		var that = this;
		self.getValidator(this.name, function(er, v) {
			if (er) return callback(er);
			if (!self.validators[that.name])
				generator.setValidator(that.name, self.validators[that.name] = createRunContext(v.code));

			return callback();
		});
	}

	function throwError(er) {
		throw new Error(er);
	}

	function parseEntities(files, fn) {
		var tasks = [function(callback) {
			return callback(null);
		}];

		for (var prop in files) {
			if (files.hasOwnProperty(prop)) {
				var item = parse(files[prop], files);

				var validate_exp = /"validate"\\s*\:\\s*"(\w+)"/ig;
				var match = validate_exp.exec(item);
				while (match) {
					tasks.push(registerValidator.bind({
						name: match[1]
					}));
					match = validate_exp.exec(item);
				}

				// Generate the Schema object.
				tasks.push(assignModel.bind({
					item: item,
					prop: prop
				}));

				self[prop] = item;
				//this more or less caches the expansion 
				files[prop] = item;
			}
		}
		async.waterfall(tasks, fn);
	}

	function parse(file, allFiles) {
		var del = self.delimiter;
		var result = file;
		var match = del.exec(file);
		while (match) {
			result.replace(match[0], parse(allFiles[match[2]]));
			match = del.exec(file);
		}
		return result;
	}
	async.waterfall([function(callback) {
			getDirectories(self.entityFolder, function(er, response) {
				if (er) {
					return callback(er);
				}
				var allFiles = {};

				response.forEach(function(filePath) {
					var data = fs.readFileSync(filePath, {
						encoding: 'utf8'
					});
					allFiles[path.basename(filePath, '.json')] = data;
				});
				callback(null, allFiles);

			});
		},
		parseEntities
	], fn || function() {});

};

module.exports = {
	Engine: DynamoEngine,
	Form: DynamoForm,
	Process: DynamoProcess,
	Step: DynamoStep,
	Processor: DynamoProcessor,
	constants: constants,
	systemEntities: systemEntities,
	EntityRepo: EntityRepo,
	Element: DynamoElement
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#capitalizeText">capitalizeText</a></li><li><a href="global.html#getDirectories">getDirectories</a></li><li><a href="global.html#getOne">getOne</a></li><li><a href="global.html#isNotDefined">isNotDefined</a></li><li><a href="global.html#typeOf">typeOf</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Jun 02 2017 15:19:06 GMT+0100 (W. Central Africa Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
